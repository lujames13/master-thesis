# III. Related Work

## A. Blockchain-based Federated Learning: Overview and Challenges (1.5頁)

### A.1 Architecture Evolution (0.5頁)

**段落1：從單聚合器到多聚合器**
- 傳統FL的中央化聚合器架構及其SPOF問題
- 區塊鏈引入提供去中心化信任層
- 多聚合器架構：負載分散、容錯增強
- 引出核心問題：如何驗證多個聚合器的正確性？

### A.2 Core Challenge: Aggregator Verification (0.7頁)

**段落2：驗證挑戰的本質**
- 問題定義：在拜占庭環境下確保聚合計算正確性
- 兩層安全模型（簡述）：
  * Client層：防禦惡意客戶端投毒（Krum、Median等，本研究正交）
  * Aggregator層：驗證聚合器計算（本研究焦點）
- 核心矛盾：效率 vs 安全性 vs 計算通用性

**段落3：三類技術路線預覽**
- PBFT-based：安全但效率低（本節B）
- Optimistic：高效但有計算限制（本節C）
- Zero-Knowledge：數學級安全但性能差（本節D）
- 混合方案：嘗試平衡但仍有缺口（本節E）

### A.3 Scope of This Review (0.3頁)

**段落4：本節組織結構**
- 聚焦多聚合器場景的驗證機制
- 按技術範式分類討論
- 不涵蓋：單聚合器方案、純PoW/PoS共識（與驗證正確性無關）

---

## B. PBFT-based Multi-Aggregator Verification (4.0頁)

### B.1 Committee-based PBFT Approaches (2.0頁)

#### B.1.1 FLCoin: Sliding Window Committee (1.2頁)

**段落1：核心機制介紹** (0.3頁)
- 滑動窗口委員會設計（window size c=100）
- 雙協議架構：
  * 快速協議（3階段）：正常情況
  * 備用協議（5階段）：異常情況
- 動態委員會選擇：基於聲譽和質押

**段落2：性能數據** (0.2頁)
- 通訊複雜度：從O(n²)降至O(3c-5c)
- 實驗結果：100節點下<5秒共識延遲
- 安全性：98.4%成功率（在特定攻擊場景）

**段落3：⭐ 批判點1 - 信任機制的長期脆弱性** (0.4頁)
FLCoin的滑動窗口和聲譽機制在短期內有效，但在長期運行場景（如醫療、金融FL）面臨**潛伏攻擊(Sleeper Attack)**的根本性威脅：

**(1) 信任積累悖論**
- 攻擊者可在t輪內保持完全誠實，建立高聲譽進入委員會
- 長期良好行為積累信任後，在關鍵時刻（t+1輪）發動攻擊
- 聲譽系統反而成為攻擊者的"保護傘"

**(2) 滑動窗口的有限記憶**
- 窗口大小有限（通常100-200輪），無法檢測超長潛伏
- 攻擊者只需在窗口內保持誠實，窗口外的異常行為被遺忘
- 長期FL訓練（數月甚至數年）為潛伏提供充足時間

**(3) 委員會局部驗證的盲區**
- 只有委員會c個節點參與驗證，非委員會成員無法cross-check
- 若攻擊者控制委員會多數（>c/3），可通過內部共謀達成惡意共識
- 外部節點無法察覺委員會內部的串謀

**段落4：批判點2 - 固定窗口的剛性** (0.2頁)
- 無法根據實時威脅動態調整委員會規模
- 低威脅時：固定c=100產生不必要驗證開銷
- 高威脅時：固定規模可能不足以提供足夠安全性
- 缺乏自適應機制

**段落5：對比本研究** (0.1頁)
- 本研究的差異：
  * 允許**任意驗證者**發起挑戰（而非僅委員會）
  * 挑戰觸發**全網PBFT驗證**（而非委員會子集）
  * 長期潛伏者一旦暴露，需面對f<n/3的全網密碼學驗證
  * PBFT提供真正的安全保障，不依賴信任積累

#### B.1.2 Other Committee-based Approaches (0.5頁)

**段落6：VFChain - 雙委員會架構** (0.2頁)
- 核心機制：驗證委員會+共識委員會
- 批判：仍是靜態配置，存在相同的潛伏攻擊風險
- 雙委員會增加系統複雜度但未解決根本問題

**段落7：MCFLM-CB - 延遲分組機制** (0.2頁)
- 核心機制：根據延遲將節點分組，優先選擇低延遲組
- 批判：分組策略仍是固定的，聲譽機制面臨潛伏攻擊

**段落8：小結** (0.1頁)
- 委員會方法的共同局限：**靜態安全策略**
- 信任機制有其價值，但不應是唯一的安全保障
- 真正的安全需要密碼學共識作為後備機制

#### B.1.3 Positioning: Trust vs. Cryptographic Consensus (0.3頁)

**段落9：論述核心觀點** (0.3頁)
本研究並非否定信任機制和聲譽系統的價值。相反，這些機制在日常運作中能有效提升效率。然而，在長期運行的生產環境FL系統中（如醫療診斷模型訓練可能持續數年），**潛伏攻擊是不可忽視的威脅**。

因此，本研究的定位是：
- **正常情況**：信任機制和樂觀執行提供高效率
- **異常情況**：PBFT密碼學共識提供根本性安全保障
- **核心哲學**：信任但驗證(Trust but Verify) - 樂觀假設但保留強驗證能力

---

### B.2 Full PBFT Verification Approaches (2.0頁)

#### B.2.1 BlockDFL: Per-Round PBFT Verification (1.0頁)

**段落10：核心機制介紹** (0.2頁)
- 完全去中心化P2P架構
- 每輪訓練都執行完整PBFT驗證
- 異常檢測結合PBFT投票

**段落11：性能數據** (0.2頁)
- 容錯能力：實驗顯示40%惡意容錯
- 但每輪需要O(V²)通訊複雜度
- V=100時，每輪約10,000條消息

**段落12：⭐ 批判點1 - 計算冗餘性** (0.3頁)
BlockDFL的"每輪都驗證"策略提供了強安全性，但存在嚴重的**計算冗餘問題**：

**(1) 威脅無關的固定開銷**
- 即使當前輪次完全無威脅，仍需全體驗證者參與
- 每個驗證者都重複執行相同的聚合計算
- 隨訓練輪數R增長，總開銷為O(R×V²)

**(2) 參與者越多越冗餘**
- 100個驗證者 → 每輪10,000次計算
- 1000個驗證者 → 每輪1,000,000次計算
- 規模擴展性極差

**(3) 無效率優化路徑**
- 沒有樂觀執行模式，無法在低威脅時降低開銷
- 無法利用"大多數情況無惡意"這一實際特性
- 資源浪費在過度驗證上

**段落13：批判點2 - 缺乏動態調整** (0.2頁)
- 無論實際威脅等級如何，始終執行相同的驗證流程
- 缺乏根據威脅動態調整驗證強度的機制
- 對比：本研究的按需觸發PBFT

**段落14：對比本研究** (0.1頁)
- 樂觀情況：O(R/N)效率，僅輪值聚合器計算
- 異常情況：按需觸發PBFT驗證，而非每輪都執行
- 動態調整：根據挑戰率自適應驗證強度

#### B.2.2 Other Full PBFT Approaches (0.7頁)

**段落15：IEEE 9223754 - Bitcoin上的PBFT FL** (0.3頁)
- 核心機制：在Bitcoin網絡上實現PBFT FL
- 技術特點：利用Bitcoin的時間戳和不可篡改性
- 批判：仍然是每輪PBFT，O(n²)瓶頸無法避免

**段落16：傳統PBFT在FL的應用** (0.3頁)
- Castro & Liskov原始PBFT[7]：三階段協議
- 在FL中的應用：直接用於驗證聚合結果
- 批判：O(n²)通訊複雜度，n>100時幾乎不可行

**段落17：小結** (0.1頁)
- 純PBFT方案的共同問題：**無樂觀模式**
- 安全性強但效率低，無法適應動態威脅
- 缺口：能否在保持PBFT安全性的同時引入樂觀執行？

#### B.2.3 Summary: The Efficiency-Security Dilemma (0.3頁)

**段落18：PBFT方案總結** (0.3頁)
現有PBFT-based方案面臨兩難困境：
- **委員會方法**（FLCoin等）：提升效率但引入信任機制，面臨潛伏攻擊
- **純PBFT方法**（BlockDFL等）：提供強安全但計算冗餘，無法擴展

**核心缺口**：
1. 缺乏動態威脅感知機制
2. 缺乏樂觀執行與Byzantine容錯的平滑切換
3. 固定驗證策略無法適應實時威脅變化

本研究通過**Optimistic-PBFT混合機制**尋求突破。

---

## C. Optimistic Verification Mechanisms (2.5頁)

### C.1 Optimistic Machine Learning (opML) (1.5頁)

#### C.1.1 Core Mechanism and Philosophy (0.3頁)

**段落19：樂觀執行原理** (0.3頁)
- 核心哲學：假設聚合器誠實，樂觀接受結果
- 挑戰期設計：7天窗口允許驗證者質疑
- 欺詐證明(Fraud Proof)：通過FPVM重新執行爭議計算
- 經濟安全：質押機制懲罰惡意行為
- 1-of-N誠實假設：只需一個誠實驗證者發現錯誤

#### C.1.2 Performance Advantages (0.2頁)

**段落20：效率分析** (0.2頁)
- 正常情況：O(1)通訊複雜度，無驗證開銷
- 挑戰情況：O(log n)交互式欺詐證明
- 實驗數據：7B LLaMA模型推理可在標準PC驗證[ref]
- 相較PBFT的O(n²)，效率提升顯著

#### C.1.3 ⭐ Core Limitation: FPVM Computational Constraints (1.0頁)

**段落21：批判點1 - 記憶體瓶頸** (0.3頁)

opML使用FPVM (Fault Proof Virtual Machine)重新執行爭議計算以生成欺詐證明。然而，FPVM存在**4GB記憶體上限**[ref]，這對大型模型FL造成嚴重限制：

| 模型 | 參數量 | 記憶體需求(FP16) | FPVM可行性 |
|------|--------|-----------------|-----------|
| BERT-Base | 110M | ~0.5GB | ✅ 可行 |
| GPT-2 | 1.5B | ~3GB | ⚠️ 接近上限 |
| LLaMA-7B | 7B | ~14GB | ❌ 超出3.5倍 |
| LLaMA-13B | 13B | ~26GB | ❌ 超出6.5倍 |
| LLaMA-70B | 70B | ~140GB | ❌ 超出35倍 |

在實際FL場景中（如醫療影像的ResNet-152、金融風控的大型Transformer），模型規模常超過FPVM限制，使opML無法驗證聚合結果。

**段落22：批判點2 - 複雜算法分解困難** (0.4頁)

FPVM要求將聚合邏輯分解為虛擬機指令層級。對於簡單算法（如FedAvg: $w = \frac{1}{n}\sum w_i$）這是可行的，但複雜算法極其困難：

**(1) FedProx算法**
```python
# FedProx: 帶正則化的聯邦優化
w_t+1 = argmin_w [F(w) + (μ/2)||w - w_t||²]
```
需要在FPVM中實現：
- 優化器（Adam/SGD）的完整狀態
- 正則化項的梯度計算
- 多輪迭代的循環控制
- 收斂判定邏輯

**(2) 複雜聚合算法（如用於Byzantine-robust）**
如果client層使用Krum等防禦算法，聚合器需執行：
```python
# Krum: 基於距離的異常檢測
for i in clients:
    score_i = Σ_{j in nearest} ||g_i - g_j||²
select argmin score_i
```
需要在FPVM中實現：
- 高維向量的歐式距離計算
- 排序算法（找最近鄰）
- 動態的top-k選擇

opML論文[ref]也承認："複雜ML算法的FPVM驗證仍是開放性問題"。實際上，算法越複雜，FPVM分解的難度和證明生成時間指數增長。

**段落23：批判點3 - 無GPU加速** (0.3頁)

FPVM必須在CPU環境執行，無法利用GPU/TPU硬體加速。對於大模型聚合的矩陣運算：

| 操作 | 原生PyTorch+GPU | FPVM CPU模擬 | 倍數差異 |
|------|----------------|-------------|---------|
| 7B模型前向傳播 | ~2秒 | ~60秒 | 30x |
| 梯度聚合(1000客戶端) | ~5秒 | ~150秒 | 30x |
| 參數更新 | ~1秒 | ~30秒 | 30x |

這使得挑戰驗證本身成為性能瓶頸。若挑戰頻繁發生，FPVM驗證的累積時間可能超過訓練本身。

#### C.1.4 Implications and本研究的差異 (0.3頁)

**段落24：opML對本研究的啟發** (0.15頁)
- 樂觀執行的效率優勢明顯（O(1) vs O(n²)）
- 挑戰期設計elegant且實用
- 1-of-N誠實假設在許可鏈場景合理
- 本研究繼承了opML的樂觀哲學

**段落25：關鍵差異與改進** (0.15頁)

| 維度 | opML | 本研究 |
|------|------|--------|
| 仲裁機制 | Fraud Proof (FPVM) | PBFT Consensus |
| 計算環境 | 虛擬機(4GB限制) | 原生環境(無限制) |
| 模型規模 | ≤2B參數 | 任意規模(7B-175B+) |
| 算法支援 | 簡單算法 | 任意Python/PyTorch代碼 |
| 硬體加速 | ❌ CPU only | ✅ GPU/TPU可用 |
| 安全保證 | 1-of-N誠實 | 1-of-N + f<n/3(雙層) |

**核心問題**：能否保留Optimistic的效率優勢，但用更通用的仲裁機制？
**本研究答案**：用PBFT共識替代Fraud Proof，在原生環境執行驗證

---

### C.2 Optimistic Rollup in Blockchain Context (0.7頁)

#### C.2.1 Ethereum Layer 2 Background (0.4頁)

**段落26：Optimistic Rollup基本原理** (0.4頁)
- 背景：Ethereum擴容方案
- 核心機制：
  * 鏈下執行交易（高吞吐）
  * 鏈上提交狀態根（安全性）
  * 挑戰期驗證（7天窗口）
  * 欺詐證明仲裁爭議
- 代表項目：Arbitrum、Optimism
- 啟發：挑戰期設計可用於FL驗證

#### C.2.2 Applicability to Federated Learning (0.3頁)

**段落27：Optimistic Rollup對FL的適用性** (0.3頁)
- 相似點：
  * 都是計算密集型任務
  * 都需要高效驗證機制
  * 都可受益於樂觀假設
- 差異點：
  * Rollup驗證EVM指令，FL驗證ML計算
  * Rollup面對金融交易，FL面對模型訓練
  * Rollup使用通用Fraud Proof，FL需要針對性設計
- 結論：通用optimistic機制有啟發，但未針對FL優化

---

### C.3 Summary: Efficiency vs. Computational Generality (0.3頁)

**段落28：Optimistic方法總結** (0.3頁)

Optimistic驗證機制展現了顯著的效率優勢（O(1) vs O(n²)），且挑戰期設計在實踐中證明有效（Ethereum Rollup生態的成功）。然而，當前opML方案面臨**計算通用性**的根本限制：

- **FPVM約束**：記憶體上限、算法分解困難、無GPU加速
- **適用場景受限**：僅支援小模型(≤2B)和簡單算法
- **FL需求衝突**：生產環境FL常涉及大模型(7B+)和複雜聚合

**核心缺口**：能否在保持樂觀效率的同時，使用更通用的仲裁機制？

本研究的創新在於：**用PBFT共識替代Fraud Proof作為仲裁機制**，從而在原生環境執行驗證，消除計算限制。

---

## D. Zero-Knowledge Proof Approaches (1.5頁)

### D.1 zkML: Zero-Knowledge Machine Learning (1.2頁)

#### D.1.1 Core Mechanism (0.3頁)

**段落29：零知識證明原理** (0.3頁)
- 基本概念：證明者向驗證者證明計算正確性，而不透露計算過程
- 在ML中的應用：對推理/聚合生成zk-SNARK/zk-STARK證明
- 算術化(Arithmetization)：將ML計算轉為算術電路
- 證明系統：Groth16、PLONK、FRI-based STARKs等
- 安全級別：數學級完整性保證，無需信任假設

#### D.1.2 ⭐ Core Limitations: Arithmetization Constraints (0.9頁)

**段落30：批判點1 - 模型規模限制** (0.3頁)

zkML需將神經網絡"算術化"為算術電路，這導致嚴重的**規模瓶頸**：

| 研究 | 模型 | 參數量 | 證明生成時間 | 可行性評估 |
|------|------|--------|-------------|-----------|
| Bahrami[8] | ResNet50 | 25M | 55分鐘 | 勉強可行 |
| Kang等[2] | 7B+ | >7B | - | "utterly impractical" |
| 實測上限[1][2] | - | ~18M | - | 實際可行上限 |

具體問題：
- **電路規模爆炸**：7B模型需約10¹²個約束，證明生成需數小時甚至數天
- **記憶體需求**：證明生成需要模型規模數倍的記憶體
- **Prover開銷**：相較原生計算慢數個數量級

在聯邦學習場景中，主流模型（如醫療影像的ViT-Large、金融的BERT-large、多模態的CLIP）均超過zkML可行規模，使其**不適合實際部署**。

**段落31：批判點2 - 算法限制** (0.3頁)

算術化只能高效處理**算術運算密集型**的簡單算法，對複雜邏輯極其困難：

**(1) 可行算法（簡單加權平均）**
```python
# FedAvg: 純算術運算
w_global = Σ (n_i / n_total) * w_i  ✅ 可算術化
```
- 只涉及乘法和加法
- 電路深度較小
- 證明生成相對快速

**(2) 困難算法（帶優化的聚合）**
```python
# FedProx: 帶正則化
w = argmin [F(w) + (μ/2)||w - w_t||²]  ❌ 算術化困難
```
- 需要迭代優化循環
- 條件分支（收斂判定）
- 梯度計算的鏈式法則

**(3) 極困難算法（Byzantine-robust）**
```python
# Krum: 排序和距離計算
score_i = Σ ||g_i - g_j||²  ❌ 算術化極困難
select argmin score_i
```
- 排序操作（比較電路深度大）
- 條件分支（選擇最小值）
- 歐式距離計算

實際上，算法越複雜，算術化的電路深度和約束數量指數增長，證明生成時間也隨之指數增長。

**段落32：批判點3 - 證明生成時間** (0.3頁)

| 任務 | 原生PyTorch | zkML證明生成 | 倍數差異 |
|------|------------|-------------|---------|
| MNIST推理(簡單CNN) | <1秒 | ~2分鐘 | 120x |
| ResNet50推理 | ~2秒 | ~55分鐘 | 1650x |
| 聚合1000客戶端(FedAvg) | ~5秒 | ~10分鐘 | 120x |

在FL場景中：
- 訓練100輪，每輪zkML證明10分鐘 → 總計1000分鐘(16小時)
- 相較原生計算(約10分鐘) → 開銷100倍
- 若挑戰頻繁，證明生成成為訓練瓶頸

#### D.1.3 對比與定位 (0.3頁)

**段落33：zkML vs 本研究** (0.3頁)

| 維度 | zkML | 本研究(Opt-PBFT) |
|------|------|------------------|
| 驗證機制 | zk-SNARK/STARK | PBFT Consensus |
| 安全級別 | 數學級(無需信任) | Byzantine容錯(f<n/3) |
| 模型規模 | ≤18M參數 | 無限制(7B-175B+) |
| 算法支援 | 僅簡單算術 | 任意算法 |
| 證明時間 | 數十分鐘-數小時 | PBFT共識(數分鐘) |
| 適用場景 | 極高信任要求+小模型 | 生產環境通用FL |

**結論**：
- zkML的零信任特性(trustless)有其獨特價值
- 但在FL場景中，性能與規模限制使其**不適合實際部署**
- 本研究通過PBFT提供足夠強的安全保證(f<n/3)，同時保持實用性

---

### D.2 Summary: Mathematical Security vs. Practicality (0.3頁)

**段落34：零知識方法總結** (0.3頁)

零知識證明提供了**數學級別的完整性保證**，無需任何信任假設，這在理論上極具吸引力。然而，當前zkML技術面臨三大實用性障礙：

1. **模型規模瓶頸**：≤18M參數上限，無法處理主流大模型
2. **算法通用性受限**：只能驗證簡單算術運算，複雜算法極困難
3. **證明生成開銷**：慢數個數量級，成為訓練瓶頸

**核心缺口**：在聯邦學習場景中，**運算通用性**比數學級安全更關鍵。

本研究的定位：在許可鏈/聯盟鏈場景下（基礎信任度較高），通過PBFT提供足夠強的Byzantine容錯保證，同時保持對任意模型規模和算法的支援。

---

## E. Hybrid Consensus Mechanisms (1.0頁)

### E.1 Layer-based Architectures (0.4頁)

**段落35：IEEE 9223754 - Optimistic Rollup on Bitcoin** (0.2頁)
- 核心機制：在Bitcoin上實現Optimistic Rollup FL
- Layer架構：Bitcoin作為Layer 1安全層，Rollup作為Layer 2執行層
- 批判：Layer分離增加系統複雜度，跨層通訊開銷大

**段落36：FLock - State Channels + PBFT** (0.2頁)
- 核心機制：狀態通道實現快速聚合，PBFT確保最終安全
- 技術特點：鏈下高頻互動，定期鏈上結算
- 批判：通道管理複雜，適用於固定參與者集合

---

### E.2 Multi-Stage Consensus (0.4頁)

**段落37：EPP-BCFL - PoS+BFT兩階段混合** (0.4頁)

**機制介紹** (0.2頁)
- 階段1：PoS選擇驗證者（基於質押）
- 階段2：BFT共識驗證聚合結果
- 目標：結合PoS效率與BFT安全

**批判：靜態兩階段 vs 動態切換** (0.2頁)
- EPP-BCFL的問題：
  * **固定執行兩階段**：無論是否有威脅，都執行完整流程
  * **非威脅感知**：沒有根據實時安全狀況調整的機制
  * **缺乏樂觀模式**：即使所有聚合器誠實，仍需BFT驗證
- 本研究的差異：
  * **動態觸發**：只在檢測到威脅時啟動PBFT
  * **威脅感知**：根據挑戰頻率調整驗證強度
  * **樂觀優先**：正常情況下O(R/N)效率

---

### E.3 Summary: Static Hybrid vs. Dynamic Adaptive (0.2頁)

**段落38：混合方案總結** (0.2頁)

現有混合共識方案嘗試平衡效率與安全，但仍採用**靜態混合策略**：
- Layer架構：固定的Layer分離
- Multi-stage：固定的兩階段流程
- 共同問題：缺乏**動態威脅感知**和**自適應調整**

**核心缺口**：能否實現真正的動態混合，根據實時威脅自動切換？

本研究的創新：**威脅感知的動態Optimistic-PBFT機制**，而非固定的混合流程。

---

## F. Research Gap and Positioning (0.5頁)

### F.1 三大未解決問題 (0.3頁)

**段落39：缺口1 - 委員會方法的長期安全脆弱性** (0.1頁)
- **問題**：固定委員會和信任機制面臨潛伏攻擊
- **根源**：信任積累、有限記憶窗口、局部驗證
- **影響**：長期運行FL系統（醫療/金融）安全堪憂
- **代表方案**：FLCoin、VFChain、MCFLM-CB

**段落40：缺口2 - 純PBFT的計算冗餘性** (0.1頁)
- **問題**：每輪都執行O(V²)驗證，無樂觀模式
- **根源**：缺乏威脅感知，無法動態調整
- **影響**：隨參與者增多，資源浪費在過度驗證
- **代表方案**：BlockDFL、IEEE 9223754

**段落41：缺口3 - 樂觀/零知識方法的運算限制** (0.1頁)
- **問題**：FPVM/算術化限制計算能力
- **根源**：為實現特定驗證機制犧牲通用性
- **影響**：無法支援大模型(>2B)或複雜算法
- **代表方案**：opML、zkML

---

### F.2 研究缺口總結與過渡 (0.2頁)

**段落42：缺口總結與本研究定位** (0.2頁)

綜上所述，現有多聚合器驗證方案面臨三大核心挑戰：

1. **委員會方法**（FLCoin等）：信任機制面臨長期潛伏攻擊風險
2. **純PBFT方法**（BlockDFL等）：固定驗證策略造成計算冗餘
3. **樂觀/零知識方法**（opML、zkML）：驗證機制限制運算通用性

這些缺口為**動態威脅感知的混合共識機制**留下研究空間。本研究通過Optimistic-PBFT動態切換，在正常情況保持高效率（O(R/N)），異常情況提供Byzantine容錯保證（f<n/3），同時支援任意模型規模和聚合算法。具體設計與實現將在第IV章詳述。
