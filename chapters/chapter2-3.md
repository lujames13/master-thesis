# 2.3 拜占庭容錯與PBFT協議

在分散式系統中，節點可能因為硬體故障、軟體錯誤或惡意攻擊而出現任意錯誤行為。拜占庭容錯（Byzantine Fault Tolerance）是分散式系統設計中的核心挑戰，而實用拜占庭容錯（Practical Byzantine Fault Tolerance, PBFT）協議則是實現拜占庭容錯最具影響力的共識機制之一。本節首先介紹拜占庭將軍問題的理論基礎，然後詳細闡述PBFT協議的三階段工作流程，接著分析其O(n²)通訊複雜度瓶頸，最後探討PBFT的安全性保證機制。

## 2.3.1 拜占庭將軍問題

拜占庭將軍問題（Byzantine Generals Problem）最早由Lamport等人於1982年提出[1]，用以描述分散式系統中存在惡意節點時如何達成共識的基本挑戰。此問題以拜占庭帝國的軍事場景作為比喻：多個將軍需要協調攻擊策略，但其中可能存在叛徒。所有忠誠的將軍必須達成一致的行動計劃（攻擊或撤退），即使某些將軍是叛徒並試圖干擾決策過程。

**問題定義**

在分散式系統中，拜占庭將軍問題可形式化為以下條件：

1. **一致性（Agreement）**：所有誠實節點必須對某個值達成共識
2. **有效性（Validity）**：若所有誠實節點提出相同的初始值，則最終共識結果應為該值
3. **終止性（Termination）**：所有誠實節點最終都會達成決定

**拜占庭節點特徵**

拜占庭節點（Byzantine node）是指表現出任意錯誤行為的節點，包括但不限於：

- **錯誤計算**：提交錯誤的計算結果
- **選擇性通信**：向不同節點發送不一致的消息
- **延遲響應**：刻意延遲消息發送以干擾協議進行
- **串謀攻擊**：多個惡意節點協同攻擊系統

與崩潰故障（Crash Fault）僅考慮節點停止工作不同，拜占庭故障假設節點可能執行任意惡意行為，因此防禦難度顯著提高。

**理論容錯上界**

Lamport等人證明，在異步通信模型下，若系統中存在f個拜占庭節點，則至少需要n ≥ 3f+1個節點才能保證系統的安全性和活性[1]。此不等式可改寫為：

$$f < \frac{n}{3}$$

這意味著系統最多只能容忍少於三分之一的節點為惡意節點。例如，在擁有21個節點的系統中，最多能容忍6個惡意節點（f = 6, n = 21, 6 < 21/3 = 7）。此理論上界為所有拜占庭容錯協議的基本限制，包括PBFT及其變體。

**安全性與活性**

拜占庭容錯系統需同時保證兩個關鍵屬性：

- **安全性（Safety）**：系統不會做出錯誤的決定，即使存在惡意節點
- **活性（Liveness）**：系統最終會做出決定，不會永遠停滯

傳統的拜占庭容錯算法（如Lamport的Paxos）雖能提供安全性保證，但往往效率較低且實作複雜。PBFT協議的創新在於在滿足拜占庭容錯理論上界的前提下，實現了高效的實用化共識機制。

## 2.3.2 PBFT三階段協議

實用拜占庭容錯（PBFT）協議由Castro和Liskov於1999年提出[2]，首次實現了可在實際系統中部署的拜占庭容錯共識機制。PBFT透過三階段消息交換和仲裁數（Quorum）機制，確保在存在惡意節點時仍能達成安全且一致的共識。

**角色與基本概念**

PBFT系統由n = 3f+1個節點組成，其中f為系統可容忍的最大拜占庭節點數。系統中的節點角色包括：

- **主節點（Primary）**：負責提議待共識的請求，並發起共識流程
- **副本節點（Replicas）**：參與共識投票，驗證主節點的提議
- **視圖（View）**：系統運行的階段標識，每個視圖對應一個主節點

PBFT的核心機制包括：

- **仲裁數（Quorum）**：至少2f+1個節點的響應集合，確保至少包含f+1個誠實節點
- **序列號（Sequence Number）**：為每個請求分配的唯一標識，防止重複執行
- **數字簽名**：所有消息都經過數字簽名，防止偽造和篡改
- **視圖切換（View Change）**：當主節點失效時，系統切換至新視圖並選舉新主節點

**三階段共識流程**

PBFT協議的共識過程包含三個關鍵階段：Pre-Prepare、Prepare和Commit。完整流程如算法1所示：

```
算法1：PBFT三階段共識協議
輸入：請求 m，視圖編號 v，序列號 n，主節點 p，副本集合 R
輸出：共識結果（接受或拒絕）

階段0：請求階段
1: 客戶端發送請求 ⟨REQUEST, o, t, c⟩_σc 至主節點 p
2: 其中 o 為操作，t 為時間戳，c 為客戶端標識，σc 為客戶端簽名

階段1：Pre-Prepare 階段
3: 主節點 p 收到請求後，分配序列號 n
4: 主節點廣播 ⟨PRE-PREPARE, v, n, d⟩_σp 至所有副本
5: 其中 d = H(m) 為請求的雜湊值，σp 為主節點簽名
6: 副本 i 驗證：
7:     - 簽名 σp 有效
8:     - 當前視圖 v 正確
9:     - 序列號 n 在合法範圍內 [h, H]
10:    - 未接受過同一視圖和序列號但不同摘要的 Pre-Prepare 消息
11: if 驗證通過 then
12:    副本 i 進入 Prepare 階段
13: end if

階段2：Prepare 階段
14: 副本 i 廣播 ⟨PREPARE, v, n, d, i⟩_σi 至所有其他節點
15: 其中 σi 為副本 i 的簽名
16: 每個副本收集來自其他節點的 Prepare 消息
17: 副本 i 驗證每條 Prepare 消息：
18:    - 簽名 σj 有效
19:    - 視圖 v 和序列號 n 與 Pre-Prepare 一致
20:    - 摘要 d 與 Pre-Prepare 一致
21: if 副本 i 收集到至少 2f 個有效 Prepare 消息（加上自己的 Pre-Prepare，共 2f+1） then
22:    副本 i 達到 prepared 狀態
23:    副本 i 進入 Commit 階段
24: end if

階段3：Commit 階段
25: 副本 i 廣播 ⟨COMMIT, v, n, d, i⟩_σi 至所有其他節點
26: 每個副本收集來自其他節點的 Commit 消息
27: 副本 i 驗證每條 Commit 消息的簽名和一致性
28: if 副本 i 收集到至少 2f+1 個有效 Commit 消息（包括自己的） then
29:    副本 i 達到 committed-local 狀態
30:    副本 i 執行請求 m
31:    副本 i 發送響應 ⟨REPLY, v, t, c, i, r⟩_σi 至客戶端
32:    其中 r 為執行結果
33: end if

階段4：客戶端確認
34: 客戶端等待至少 f+1 個相同的響應
35: if 收集到 f+1 個相同響應 then
36:    return 共識達成，結果為 r
37: else
38:    return 超時，重新發送請求
39: end if
```

**關鍵機制說明**

**(1) 2f+1仲裁數的意義**

在n = 3f+1個節點中，任意2f+1個節點的集合稱為仲裁數（Quorum）。由於系統最多有f個惡意節點，因此任何仲裁數至少包含f+1個誠實節點。這確保了：

- 任意兩個仲裁數至少有f+1個共同節點
- 這些共同節點中至少有一個誠實節點
- 誠實節點會拒絕相互衝突的提議，從而保證一致性

**(2) 三階段的必要性**

- **Pre-Prepare階段**：主節點提議並分配序列號，確保全局順序
- **Prepare階段**：副本之間交換信息，確認收到一致的提議
- **Commit階段**：再次確認所有誠實節點都已準備好執行，防止主節點惡意行為

三階段設計確保即使主節點是惡意的，誠實節點仍能檢測出不一致並達成共識。

**(3) 視圖切換機制**

當副本檢測到主節點失效（如超時未響應）時，會觸發視圖切換：

1. 副本停止接受當前視圖的消息
2. 副本廣播VIEW-CHANGE消息至新主節點
3. 新主節點收集2f+1個VIEW-CHANGE消息後
4. 新主節點廣播NEW-VIEW消息，包含未完成請求的證明
5. 系統進入新視圖，由新主節點繼續處理請求

視圖切換確保即使主節點故障，系統仍能保持活性。

**消息流程圖**

圖2.1展示了PBFT協議在正常情況下的消息流程。客戶端發送請求至主節點，主節點廣播Pre-Prepare消息，隨後副本之間交換Prepare和Commit消息，最終所有誠實節點達成一致並回覆客戶端。

```
客戶端                主節點 (0)         副本1          副本2          副本3
  |                      |                |              |              |
  |----REQUEST---------->|                |              |              |
  |                      |                |              |              |
  |                      |--PRE-PREPARE-->|              |              |
  |                      |--PRE-PREPARE----------------->|              |
  |                      |--PRE-PREPARE------------------------------>|
  |                      |                |              |              |
  |                      |<---PREPARE-----|              |              |
  |                      |<---PREPARE----------------------|              |
  |                      |<---PREPARE------------------------------------|
  |                      |                |              |              |
  |                      |                |<--PREPARE----|              |
  |                      |                |<--PREPARE----------------->|
  |                      |                |              |              |
  |                      |---COMMIT------>|              |              |
  |                      |---COMMIT------------------------->|              |
  |                      |---COMMIT------------------------------------->|
  |                      |                |              |              |
  |                      |<---COMMIT------|              |              |
  |                      |<---COMMIT---------------------|              |
  |                      |<---COMMIT------------------------------------|
  |                      |                |              |              |
  |<----REPLY------------|                |              |              |
  |<----REPLY----------------------------|              |              |
  |<----REPLY-------------------------------------------|              |
  |<----REPLY-------------------------------------------------------|
  |                      |                |              |              |
```

圖2.1：PBFT三階段消息流程圖（n=4, f=1）

**PBFT的優勢與局限**

PBFT協議的主要優勢包括：

- **實用性**：相較於早期拜占庭容錯算法，PBFT顯著降低了計算和通訊開銷
- **確定性終止**：在部分同步網路模型下，協議能夠保證終止
- **高吞吐量**：實驗顯示PBFT在區域網環境下能達到數千筆交易/秒

然而，PBFT也存在可擴展性限制，其根本原因在於O(n²)的通訊複雜度，這將在下一節詳細分析。

## 2.3.3 O(n²)通訊複雜度分析

PBFT協議的主要性能瓶頸在於其通訊複雜度。本節詳細推導PBFT的O(n²)通訊開銷，並分析其對系統可擴展性的影響。

**消息數量推導**

在PBFT協議中，每個共識回合需要經歷三個階段的消息交換。假設系統有n = 3f+1個節點，我們分析每個階段的消息數量：

**(1) Pre-Prepare階段**

主節點向所有副本廣播Pre-Prepare消息：

$$M_{\text{pre}} = n - 1 = O(n)$$

由於主節點需要向其他n-1個節點發送消息，此階段的通訊複雜度為O(n)。

**(2) Prepare階段**

每個副本（包括主節點）在收到Pre-Prepare消息後，向所有其他節點廣播Prepare消息：

$$M_{\text{prepare}} = n \times (n - 1) = n^2 - n = O(n^2)$$

具體而言：
- n個節點各自發送Prepare消息
- 每個節點發送給其他n-1個節點
- 總消息數為n×(n-1)

**(3) Commit階段**

每個副本在達到prepared狀態後，向所有其他節點廣播Commit消息：

$$M_{\text{commit}} = n \times (n - 1) = n^2 - n = O(n^2)$$

此階段的消息模式與Prepare階段相同，每個節點都需要向其他所有節點廣播。

**(4) 總消息數**

將三個階段的消息數相加：

$$M_{\text{total}} = M_{\text{pre}} + M_{\text{prepare}} + M_{\text{commit}}$$

$$M_{\text{total}} = (n-1) + (n^2-n) + (n^2-n)$$

$$M_{\text{total}} = 2n^2 - n - 1 = O(n^2)$$

因此，PBFT協議每個共識回合的通訊複雜度為O(n²)。

**實證數據分析**

表2.1展示了不同節點數量下PBFT協議的消息數量：

| 節點數 n | 容錯數 f | Pre-Prepare | Prepare | Commit | 總消息數 |
|---------|---------|------------|---------|--------|---------|
| 4       | 1       | 3          | 12      | 12     | 27      |
| 7       | 2       | 6          | 42      | 42     | 90      |
| 10      | 3       | 9          | 90      | 90     | 189     |
| 21      | 6       | 20         | 420     | 420    | 860     |
| 50      | 16      | 49         | 2,450   | 2,450  | 4,949   |
| 100     | 33      | 99         | 9,900   | 9,900  | 19,899  |

表2.1：不同節點數量下的PBFT消息數量

從表2.1可觀察到：

- 當n=21時，每個共識回合需要860條消息
- 當n=100時，消息數量激增至近2萬條
- 消息數量隨節點數呈平方增長

**網路帶寬消耗**

除了消息數量，每條消息的大小也影響總帶寬消耗。假設每條PBFT消息包含：

- 視圖編號和序列號：8 bytes
- 請求摘要：32 bytes（SHA-256）
- 數字簽名：64 bytes（ECDSA）
- 其他元數據：16 bytes

每條消息約為120 bytes。若每個共識回合處理的請求數據為1 KB，則n=100時：

$$\text{總帶寬} = 19,899 \times 120 \text{ bytes} + 1,000 \text{ bytes} \approx 2.39 \text{ MB/回合}$$

若系統需要達到100回合/秒的吞吐量，則網路總帶寬需求為：

$$\text{帶寬需求} = 2.39 \text{ MB} \times 100 = 239 \text{ MB/s} = 1.91 \text{ Gb/s}$$

這對於廣域網環境是極大的挑戰。

**可擴展性瓶頸**

O(n²)通訊複雜度導致PBFT在節點數量增加時性能顯著下降：

**(1) 節點處理負擔**

每個節點在Prepare和Commit階段需要：
- 發送n-1條消息
- 接收n-1條消息
- 驗證n-1個數字簽名

驗證數字簽名是計算密集型操作。若單個ECDSA簽名驗證耗時0.1毫秒，則n=100時每個節點需花費：

$$T_{\text{verify}} = 99 \times 0.1 \text{ ms} \times 2 \text{ 階段} = 19.8 \text{ ms}$$

僅簽名驗證就佔用接近20毫秒，限制了系統的最大吞吐量。

**(2) 網路擁塞**

在大規模節點部署（如n>100）時，O(n²)消息交換可能導致網路擁塞，進一步增加延遲和超時概率，影響系統活性。

**(3) 實務部署限制**

由於上述因素，實務中的PBFT系統通常將節點數量限制在10-30個：

- 許可鏈系統（如Hyperledger Fabric）典型配置為10-20個共識節點
- 超過100個節點的PBFT部署幾乎不可行

**複雜度對比**

表2.2對比了不同共識機制的通訊複雜度：

| 共識機制 | 通訊複雜度 | 容錯類型 | 實務節點上限 |
|---------|-----------|---------|-------------|
| PBFT    | O(n²)     | Byzantine | 10-30 |
| Raft    | O(n)      | Crash     | 100+ |
| Paxos   | O(n)      | Crash     | 100+ |
| PoW     | O(n)      | Byzantine | 無限制 |

表2.2：不同共識機制的通訊複雜度對比

PBFT的O(n²)複雜度是其提供拜占庭容錯能力的代價。雖然提供了強安全保證，但可擴展性受限，這也是本研究提出混合Optimistic-PBFT機制的主要動機之一。

## 2.3.4 PBFT安全性保證

PBFT協議能夠在存在惡意節點時保證系統的安全性和一致性，其核心安全機制建立在仲裁數（Quorum）和交集定理之上。本節分析PBFT如何實現f < n/3的容錯保證。

**容錯度分析**

根據拜占庭容錯理論，PBFT系統的節點總數必須滿足n ≥ 3f+1，其中f為最大容錯節點數。這可改寫為：

$$f < \frac{n}{3}$$

此不等式表明，PBFT最多能容忍少於三分之一的節點為惡意節點。例如：

- n=4時，f=1（容錯率25%）
- n=7時，f=2（容錯率28.6%）
- n=10時，f=3（容錯率30%）
- n=21時，f=6（容錯率28.6%）

**2f+1仲裁數機制**

PBFT的安全性依賴於2f+1仲裁數（Quorum）機制。在n = 3f+1個節點的系統中：

**(1) 仲裁數的組成**

任何包含至少2f+1個節點的集合稱為仲裁數。由於系統最多有f個惡意節點，因此任何仲裁數至少包含：

$$\text{誠實節點數} = (2f+1) - f = f+1$$

這確保了每個仲裁數中誠實節點佔多數。

**(2) 數學證明**

設系統中誠實節點數為h，惡意節點數為b，則：

$$h + b = n = 3f+1$$

由於b ≤ f，因此：

$$h = n - b \geq n - f = (3f+1) - f = 2f+1$$

這證明了誠實節點數至少為2f+1，能夠形成一個完整的仲裁數。

**Quorum交集定理**

PBFT安全性的關鍵在於任意兩個仲裁數必定有交集，且交集中至少包含一個誠實節點。

**(1) 交集大小證明**

設Q₁和Q₂為兩個仲裁數，每個包含至少2f+1個節點。它們的交集大小為：

$$|Q_1 \cap Q_2| \geq |Q_1| + |Q_2| - n$$

$$|Q_1 \cap Q_2| \geq (2f+1) + (2f+1) - (3f+1)$$

$$|Q_1 \cap Q_2| \geq 4f + 2 - 3f - 1 = f + 1$$

因此，任意兩個仲裁數至少有f+1個共同節點。

**(2) 誠實節點存在證明**

由於系統最多有f個惡意節點，而交集大小至少為f+1，根據鴿籠原理，交集中至少有：

$$\text{誠實節點數} = (f+1) - f = 1$$

這確保了任意兩個仲裁數的交集中至少有一個誠實節點。

**安全性保證機制**

**(1) 防止雙重共識**

假設惡意主節點試圖對同一序列號n發起兩個不同的提議m₁和m₂：

1. 主節點向Q₁發送⟨PRE-PREPARE, v, n, H(m₁)⟩
2. 主節點向Q₂發送⟨PRE-PREPARE, v, n, H(m₂)⟩

若Q₁和Q₂都達成prepared狀態，則：
- Q₁中至少2f+1個節點接受了m₁
- Q₂中至少2f+1個節點接受了m₂

根據交集定理，Q₁和Q₂的交集至少有f+1個節點，其中至少有一個誠實節點。誠實節點會拒絕對同一序列號接受不同的提議，因此此攻擊無法成功。

**(2) 防止惡意提交**

在Commit階段，每個節點需要收集至少2f+1個Commit消息才能執行請求。由於仲裁數中至少有f+1個誠實節點，而誠實節點只會對正確的請求發送Commit消息，因此惡意節點無法單獨形成有效的仲裁數。

**(3) 視圖切換安全性**

在視圖切換過程中，新主節點需要收集至少2f+1個VIEW-CHANGE消息才能進入新視圖。這確保了新主節點能夠獲得至少f+1個誠實節點的狀態信息，從而正確恢復未完成的請求。

**安全性數學模型**

設系統達成錯誤共識的概率為P(error)。在PBFT中，錯誤共識發生當且僅當存在一個仲裁數完全由惡意節點控制，即：

$$P(\text{error}) = P(\text{存在仲裁數被完全控制})$$

由於仲裁數大小為2f+1，而惡意節點最多為f個，因此：

$$P(\text{error}) = 0 \quad \text{當} \quad f < \frac{n}{3}$$

這證明了在滿足f < n/3條件下，PBFT能夠提供完美的安全性保證。

**實務安全考量**

雖然PBFT在理論上提供了強安全保證，但實務部署仍需考慮：

**(1) 數字簽名安全**

PBFT依賴數字簽名防止消息偽造。若簽名算法被破解（如量子計算攻擊），系統安全性將受威脅。

**(2) 網路同步假設**

PBFT假設網路最終同步（消息延遲有上界）。在網路分區或高延遲環境下，活性可能受影響。

**(3) 視圖切換攻擊**

惡意節點可能頻繁觸發視圖切換以降低系統性能，雖不影響安全性但會影響活性。

**安全性總結**

表2.3總結了PBFT的安全性特徵：

| 安全屬性 | PBFT保證 | 條件 |
|---------|---------|------|
| 一致性（Agreement） | 所有誠實節點達成相同決定 | f < n/3 |
| 有效性（Validity） | 決定來自某個誠實節點的提議 | f < n/3 |
| 終止性（Termination） | 最終達成決定 | 網路最終同步 |
| 容錯度 | 最多f個惡意節點 | f < n/3 |
| 安全性級別 | 完美（理論保證） | 密碼學假設 |

表2.3：PBFT安全性特徵總結

PBFT通過巧妙的仲裁數機制和三階段協議，實現了在存在惡意節點時的安全共識。2f+1仲裁數確保了任意兩個決定之間必有誠實節點的參與，從而防止了雙重共識和惡意提交。這種設計為後續的許多拜占庭容錯協議（包括本研究的混合Optimistic-PBFT機制）奠定了理論基礎。

---

**本節小結**

本節詳細介紹了拜占庭容錯與PBFT協議的核心概念。首先，我們闡述了拜占庭將軍問題的理論基礎，說明了f < n/3的理論容錯上界。接著，我們深入分析了PBFT的三階段共識流程，包括Pre-Prepare、Prepare和Commit階段的運作機制。隨後，我們推導了PBFT的O(n²)通訊複雜度，指出其在大規模部署時的可擴展性瓶頸。最後,我們探討了PBFT的安全性保證機制，證明了2f+1仲裁數和Quorum交集定理如何確保系統在惡意節點存在時仍能達成安全共識。

PBFT協議雖然提供了強大的拜占庭容錯保證，但其O(n²)通訊複雜度限制了系統的可擴展性。這一限制是本研究提出混合Optimistic-PBFT機制的主要動機之一：在正常情況下採用樂觀假設以降低通訊開銷，僅在檢測到惡意行為時啟動完整的PBFT共識，從而實現效率與安全性的平衡。

---

**參考文獻**

[1] L. Lamport, R. Shostak, and M. Pease, "The Byzantine Generals Problem," ACM Transactions on Programming Languages and Systems, vol. 4, no. 3, pp. 382-401, July 1982.

[2] M. Castro and B. Liskov, "Practical Byzantine Fault Tolerance," in Proceedings of the Third Symposium on Operating Systems Design and Implementation (OSDI), New Orleans, USA, Feb. 1999, pp. 173-186.
