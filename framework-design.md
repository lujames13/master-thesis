# 第四章 研究方法與架構

本章提出一個基於區塊鏈的多聚合器聯邦學習框架，融合創新的混合Optimistic-PBFT安全機制。我們首先介紹系統整體架構及其核心組件，然後詳述從設置到學習再到挑戰的完整工作流程。本章重點闡述多聚合器模型的設計原理、挑戰機制的運作方式、混合共識機制的動態切換策略，以及惡意行為的排除與恢復機制。通過安全模型分析和計算複雜度比較，我們展示了該框架如何在保持高效率輪替分工的同時，在必要時提供完整的拜占庭容錯保護，實現效率與安全性的最佳平衡。

**研究定位與貢獻層次**：本研究針對聯盟鏈/許可鏈場景中的區塊鏈聯邦學習，提出一個基於混合Optimistic-PBFT機制的多聚合器框架。相較於傳統PBFT方案（如FLCoin [9]）每次聚合都需執行完整共識協議導致O(n²)通信開銷，本框架通過樂觀通過機制在正常情況下實現平均O(1)複雜度，大幅提升系統效率（**主要貢獻**）。同時，相較於opML [3]使用fraud proof的FPVM限制（記憶體上限4GB、無GPU加速、複雜邏輯分解困難）和zkML [1][4]的算術化瓶頸（實際可驗證上限約18M參數、證明生成耗時數十分鐘），本框架採用PBFT作為挑戰仲裁機制，驗證者在原生環境執行聚合，實現對任意聚合算法（FedAvg、FedProx、Krum、Median等）和任意模型規模（7B-175B參數）的支援（**次要貢獻**）。這種設計使得本框架適合生產環境的真實聯邦學習應用。

## 4.1 系統架構

本文提出的區塊鏈聯邦學習（BFL）框架在傳統聯邦學習架構基礎上，引入多聚合器機制並結合混合Optimistic-PBFT安全機制。系統採用雙層安全原則，在正常運作期間利用輪替選擇機制確保效率，在挑戰解決期間啟動拜占庭容錯機制確保安全性。

![系統架構圖](utils/BFL-L2-secure-aggregation.png)

如圖 4.1 所示，我們的系統設計將傳統的中心化聚合架構升級為多聚合器分散式架構。在正常運作期間，聚合器按照輪替方式負責處理客戶端更新，而驗證者網路則在後臺監控聚合結果的合法性。當檢測到可疑行為時，驗證者可以發起挑戰，系統隨即啟動PBFT共識機制進行驗證。

系統運作基於以下核心設計原則：

1. **樂觀執行（1-of-N 假設）**：假設大多數聚合器誠實，至少一個驗證者會發現並挑戰錯誤，優先採用高效的輪替機制
2. **挑戰驗證**：提供挑戰期間，允許驗證者質疑可疑的聚合結果
3. **拜占庭容錯（M-of-N 假設，M > 2/3）**：當挑戰發生時，啟動PBFT共識確保安全性
4. **計算通用性**：驗證者在原生環境執行聚合，無FPVM或算術化限制，支援任意聚合算法和模型規模
5. **經濟激勵**：透過質押機制防止惡意行為，透過獎勵機制鼓勵參與

系統中各個核心組件的角色和功能如下：

1. 請求者(Requester)：作為系統的任務發起方，負責定義聯邦學習任務的關鍵參數，包括模型架構、學習率、聚合算法和訓練輪數等。請求者可以是希望利用分散式數據進行模型訓練的組織或研究機構，他們設定任務目標並監控整體訓練進度。

2. 客戶端(Clients)：作為整個系統的數據提供者，他們在本地私有數據集上執行模型訓練。每個客戶端從IPFS下載當前全局模型，在本地數據上進行一定輪次的訓練，然後將更新後的模型參數上傳至IPFS並將雜湊值提交至區塊鏈。客戶端無需相互交流或暴露原始數據，從而保護了數據隱私。

3. 邊緣伺服器(Edge Servers)：作為系統中的聚合器，根據輪替機制分擔聚合工作。每個聚合器只需處理部分訓練輪次，大幅減輕了單一伺服器的計算負擔。當輪到特定聚合器工作時，它會收集當前輪次所有客戶端的模型更新，執行聚合算法，並將新的全局模型提交至系統。這種多聚合器設計提高了系統的容錯能力和可擴展性。

4. 驗證者網路(Validator Network)：扮演系統安全守護者的角色。驗證者持續監控鏈上的聚合結果，尋找可能的異常模式。在挑戰期間內，任何驗證者如發現可疑行為，都可以發起挑戰。一旦挑戰發生，驗證者網路會啟動PBFT共識過程，執行獨立的聚合計算並投票決定挑戰結果。驗證者透過質押機制確保誠實行為，成功的挑戰可獲得獎勵。

5. 挑戰機制(Challenge Mechanism)：我們系統的核心創新，它結合了樂觀執行和嚴格驗證的優點。在挑戰期間內，任何驗證者都可針對可疑的聚合結果發起挑戰。系統會比較被挑戰的結果與PBFT共識結果，若差異顯著，則判定挑戰成功並採取相應的恢復措施。這種機制允許系統在大多數情況下高效運行，同時保持對潛在攻擊的強大防禦能力。

6. 區塊鏈層(Blockchain Layer)：作為系統的信任基礎，提供不可篡改的記錄和透明的協調機制。所有關鍵操作，包括模型雜湊提交、聚合結果發布和挑戰結果確認，都記錄在區塊鏈上。區塊鏈層還負責執行智能合約邏輯，管理質押、驗證挑戰和分配獎勵，確保系統規則的自動執行和公正性。

7. IPFS層(IPFS Layer)：此資料儲存系統解決了區塊鏈存儲大型模型的限制問題。由於模型參數通常體積較大，直接存儲在區塊鏈上成本過高，IPFS提供了一個分散式的存儲解決方案。客戶端和聚合器將模型存儲在IPFS上，並只將對應的雜湊值提交至區塊鏈，大幅降低了存儲成本，同時通過雜湊值確保了數據的完整性和可驗證性。

這種多層次的架構設計使我們的系統能在保持去中心化和安全性的同時，實現高效的聯邦學習過程。系統的樂觀執行模式確保了在正常情況下的高效率，而挑戰機制和PBFT共識則為異常情況提供了堅實的安全保障。

## 4.2 系統工作流程

![系統序列圖](utils/sequenceDiagram.mmd)

根據圖 4.2 所示，本框架的完整工作流程可詳細描述如下：

### 初始階段
1. **全局模型初始化**：請求者（Requester）初始化聯邦學習任務，定義模型架構、學習參數與訓練目標，並將初始全局模型上傳至IPFS節點。
2. **配置設定**：系統設置多聚合器輪替機制，配置驗證者網路，並在區塊鏈上註冊任務參數與初始模型雜湊值。

### 訓練階段
1. **模型分發**：客戶端（FL clients）從IPFS節點下載當前全局模型（步驟1）。
2. **本地訓練**：各客戶端使用私有數據集對模型進行本地訓練，生成更新後的本地模型（步驟2）。
3. **更新存儲**：客戶端將訓練後的本地模型上傳至IPFS節點，同時將模型保存用於潛在的聚合或挑戰驗證（步驟3）。
4. **提交雜湊**：客戶端將本地模型的雜湊值提交至區塊鏈的樂觀層（Optimistic rollup）（步驟4）。

### 聚合階段
1. **雜湊收集**：當前輪次的指定聚合器（根據輪替機制選擇）從區塊鏈獲取所有客戶端提交的模型雜湊值（步驟5）。
2. **模型獲取**：聚合器從IPFS節點獲取對應的客戶端本地模型（步驟6）。
3. **執行聚合**：聚合器執行聯邦平均（FedAvg）或其他指定的聚合算法，生成新的全局模型。
4. **結果存儲**：聚合器將新的全局模型上傳至IPFS節點（步驟7）。
5. **提交結果**：聚合器將全局模型的雜湊值提交至區塊鏈，開始挑戰期間（步驟8）。

### 挑戰與驗證階段（可選）
1. **監控與檢測**：驗證者網路持續監控聚合結果，若發現可疑行為，可在挑戰期間內發起挑戰（步驟9）。
2. **挑戰驗證**：一旦收到挑戰，系統啟動PBFT共識機制，至少2f+1個驗證者執行獨立聚合並提交結果。
3. **結果比對**：系統比較被挑戰的聚合結果與PBFT共識結果，若差異超過預設閾值，判定挑戰成功。
4. **回滾處理**：若挑戰成功，系統回滾至上一個安全狀態（步驟10），排除惡意聚合器，並重新分配聚合任務。

### 獎勵分配階段
1. **挑戰期間結束**：無論是否有挑戰發生，系統在挑戰期間結束後進行獎勵分配。
2. **獎勵發放**：根據預設規則，系統向誠實參與者（客戶端、聚合器和驗證者）分配獎勵（步驟11）。
   - 若挑戰失敗：挑戰者損失質押，被挑戰的聚合器獲得額外獎勵。
   - 若挑戰成功：挑戰者獲得獎勵，惡意聚合器損失質押。

### 新輪次準備
1. **下一輪啟動**：系統根據輪替機制選擇下一個聚合器負責下一輪聚合。
2. **參數更新**：更新系統狀態，包括排除列表、安全指標和參與者信譽值。

整個流程形成一個閉環，從模型分發到本地訓練，再到聚合與驗證，最後進行獎勵分配並準備下一輪訓練。系統的核心特點在於樂觀假設下的高效運行，同時在檢測到可疑行為時能夠無縫切換至嚴格的PBFT共識機制，實現安全性與效率的最佳平衡。

該設計允許系統在大多數情況下以輪替(Round-Robin)分工高效運行，同時保留在必要時啟動 PBFT 共識以確保安全性的能力。這種混合方法特別適合實際部署環境，其中大多數參與者通常是誠實的，而拜占庭錯誤相對罕見。

## 4.3 多聚合器模型

相較於傳統的單一聚合器聯邦學習系統，我們的框架採用多聚合器輪替運作模式。這種設計透過分散計算負荷提升系統效率，同時透過挑戰機制維持安全性。

**多聚合器選擇演算法**：

```
演算法 1：多聚合器選擇與聚合過程
輸入：當前回合 r，聚合器總數 N，排除清單 E
輸出：選定的聚合器 ID a

1: a ← (r-1) mod N
2: while a ∈ E do
3:     r ← r + 1
4:     a ← (r-1) mod N
5: end while
6: return a
```

**聚合責任分配**：

在多聚合器架構下，每個聚合器僅需負責 $\frac{R}{N}$ 的聚合任務，其中 R 為總回合數，N 為聚合器總數。這種分散化的設計具有以下優勢：

1. **計算負荷分散**：單一聚合器不需承擔所有計算壓力
2. **容錯能力增強**：單一聚合器故障不會導致系統完全停止
3. **可擴展性提升**：可透過增加聚合器數量來處理更大規模的聯邦學習任務

## E. 挑戰機制設計

### 關鍵創新：PBFT仲裁 vs Fraud Proof仲裁

傳統Optimistic方案（如opML [3]）使用fraud proof進行挑戰仲裁，需要通過FPVM (Fault Proof Virtual Machine) 重新執行計算，導致：
- **記憶體限制**：FPVM記憶體上限為4GB，無法載入大型模型
- **無GPU加速**：FPVM必須在CPU上模擬執行，無法利用GPU加速
- **複雜邏輯分解困難**：需要將聚合邏輯分解為VM指令層級，對於帶正則化的優化問題（如FedProx）或需要排序/距離計算的算法（如Krum），分解過程極其複雜甚至不可行

**本研究的關鍵洞察**：挑戰期機制不必然要用fraud proof仲裁。我們採用PBFT共識作為仲裁機制，驗證者在原生環境執行聚合計算（無FPVM限制），從而支援任意聚合算法和模型規模。這種設計在保持樂觀通過效率的同時，獲得了計算通用性。

我們的系統整合了一個混合挑戰機制，結合了樂觀假設的效率和拜占庭容錯的安全保證。這種方法允許驗證者在指定的挑戰期間對潛在的惡意聚合結果發起挑戰。

**挑戰觸發條件**：

驗證者可在以下情況發起挑戰：
1. 聚合結果明顯偏離預期（如模型性能急劇下降）
2. 聚合器行為異常（如響應時間過長、通信模式異常）
3. 基於歷史數據的異常檢測觸發警報

**挑戰處理流程**：

```
演算法 2：挑戰提交與驗證流程
輸入：聚合結果 G_r，挑戰期間 T，驗證者集合 V
輸出：挑戰結果 (成功|失敗)

1: 進入挑戰期間 T
2: for t = 1 to T do
3:     if 收到挑戰(c) from v_i ∈ V then
4:         啟動 PBFT 驗證程序
5:         收集至少 2f+1 個驗證者回應
6:         執行拜占庭共識驗證
7:         if 挑戰有效 then
8:             執行回滾程序
9:             將惡意聚合器加入排除清單
10:            return 挑戰成功
11:        else
12:            對挑戰者施加懲罰
13:            return 挑戰失敗
14:        end if
15:    end if
16: end for
17: return 無挑戰
```

**挑戰期間設計考量**：

挑戰期間 T 的設計需要平衡效率與安全性：
- T過短：驗證者可能沒有足夠時間檢測惡意行為
- T過長：系統整體效率降低，延遲增加

建議的設計原則：
$$T = max(T_{min}, \alpha \cdot T_{aggregate})$$

其中 $T_{min}$ 為最小挑戰期間，$T_{aggregate}$ 為聚合時間，$\alpha$ 為調整係數。

## F. 混合Optimistic-PBFT共識機制

我們框架的核心創新在於將混合Optimistic-PBFT方法應用於聯邦學習。這種機制採用**雙層安全模型**，結合兩種信任假設的優勢，在需要時結合了樂觀假設的效率和拜占庭容錯共識的安全保證。

**第一層：Optimistic Detection（1-of-N 誠實假設）**

在正常運作期間，系統依賴樂觀檢測機制：
- **信任假設**：只要有至少一個誠實驗證者在線並檢查結果，就能發現錯誤並提出挑戰
- **運作流程**：聚合者發布結果 → 挑戰期 → 驗證者監控 → 無人挑戰 → 結果確認
- **安全保證**：依賴 1-of-N 假設（至少一個誠實驗證者會發現問題並挑戰）

在樂觀模式下，系統具有以下特性：
- **高效執行**：聚合complexity為 O(n)，其中 n 為參與客戶端數；通信開銷為 O(1)
- **低延迟**：無需等待多重確認，聚合完成即可繼續
- **資源節約**：不需要額外的驗證計算

**第二層：PBFT Arbitration（M-of-N 誠實假設，M > 2/3）**

當檢測到問題並發起挑戰時，系統啟動PBFT仲裁機制：
- **信任假設**：需要超過 2/3 的驗證者誠實（M-of-N 假設，其中 M > 2N/3）
- **運作流程**：挑戰觸發 → 全體驗證者重新計算 → PBFT 共識
- **安全保證**：提供完整的拜占庭容錯保護（Byzantine 容錯）
- **關鍵特性**：驗證者在原生環境執行（**不使用 fraud proof**），因此無 FPVM 的計算限制

當挑戰發生時，系統啟動拜占庭共識驗證程序：

```
演算法 3：PBFT挑戰驗證程序
輸入：被挑戰的聚合結果 G_r，驗證者回應集合 R
輸出：共識結果 C

1: 收集至少 2f+1 個驗證者獨立計算的聚合結果
2: 將相似結果分組 (使用歐幾里得距離)
3: if |最大群組| ≥ 2f+1 then
4:     C ← median(最大群組的結果)
5:     if distance(G_r, C) > θ then
6:         return 挑戰有效
7:     else
8:         return 挑戰無效
9:     end if
10: else
11:     return 無法達成共識
12: end if
```

**模式切換機制**：

系統支援動態模式切換：

$$\text{模式} = \begin{cases} 
\text{Optimistic} & \text{if } \text{無挑戰} \\
\text{PBFT} & \text{if } \text{挑戰發生}
\end{cases}$$

這種設計確保系統在大多數時間保持高效，僅在必要時切換到安全但較慢的PBFT模式。

**雙層安全模型的優勢**：

這種雙層模型提供了「防禦縱深」(Defense in Depth)：
- **正常情況**：依賴 1-of-N 的低成本監控，實現高效率運作
- **異常情況**：啟動 M-of-N 的強安全仲裁，提供拜占庭容錯保證

相比單層模型：
- 比純 Optimistic 更安全（有 PBFT 作為最後防線）
- 比純 PBFT 更高效（大多數情況樂觀通過）
- 比 opML/zkML 更通用（原生環境執行，無計算限制）

## G. 排除與恢復機制

當透過成功的PBFT驗證的挑戰檢測到惡意行為時，系統採用完善的恢復機制。包括回滾到安全狀態、排除惡意聚合器，以及將任務重新分配給誠實聚合器。

**惡意行為檢測標準**：

系統使用以下標準判定聚合器是否為惡意：

$$\text{惡意判定} = \begin{cases} 
\text{True} & \text{if } d(G_{challenged}, G_{consensus}) > \theta \\
\text{False} & \text{otherwise}
\end{cases}$$

其中 $d(\cdot, \cdot)$ 為距離函數，$\theta$ 為預設閾值。

**恢復協議**：

```
演算法 4：惡意聚合器恢復程序
輸入：惡意聚合器 A_m，當前回合 r
輸出：更新的系統狀態

1: 回滾至最後驗證狀態（回合 r-1）
2: E ← E ∪ {A_m}  // 將 A_m 加入排除清單
3: 對 A_m 實施經濟懲罰（削減質押）
4: 選擇下一個合格聚合器 A_j，其中 j ∉ E
5: 從回合 r 開始，由 A_j 重新執行聚合
6: 更新安全度量和系統狀態
```

**動態排除機制**：

排除清單支援動態管理：
- **臨時排除**：對於輕微違規，實施時間限制的排除
- **永久排除**：對於嚴重違規，實施永久排除
- **恢復機制**：允許被排除的聚合器在滿足特定條件後重新加入

**系統恢復度量**：

設定系統的安全級別 $S_t$ 在時間 $t$ 的值為：

$$S_t = \frac{N - |E_t|}{N} \times \frac{\text{成功回合數}}{t}$$

其中 $|E_t|$ 為時間 $t$ 的排除聚合器數量。目標是維持 $S_t > S_{min}$，其中 $S_{min}$ 為系統可接受的最低安全級別。

## H. 安全模型與假設

我們的混合安全模型結合了樂觀方法的效率和拜占庭容錯的強安全保證。系統安全性依賴於經濟誘因和在挑戰發生時的拜占庭共識。

**安全假設**：

本系統採用雙層安全模型，分別對應不同的信任假設：

1. **正常運作期間（Optimistic Detection，1-of-N 誠實假設）**：
   - 至少存在一個誠實驗證者監控鏈上數據並發現異常
   - 挑戰提交無法被惡意行為者審查
   - 挑戰期間 $T$ 足夠長，可進行驗證
   - 網路具有最終一致性

2. **挑戰解決期間（PBFT Arbitration，M-of-N 誠實假設，M > 2/3）**：
   - 至少 $2f+1$ 個驗證者是誠實的，其中 $f < \frac{n}{3}$（即超過 2/3 誠實）
   - 驗證者具有足夠的計算資源進行聚合計算
   - 驗證者在原生環境執行（無 FPVM 或算術化限制）
   - 網路為PBFT共識提供最終同步性
   - 消息不會被無限期延遲

3. **一般假設**：
   - 質押金額足以阻止惡意行為
   - 惡意聚合器無法與超過 $f$ 個驗證者串謀
   - 密碼學假設：數位簽章安全、雜湊函數無碰撞

**攻擊模型**：

我們考慮以下攻擊場景：

1. **拜占庭聚合器**：產生錯誤的聚合結果
2. **延遲攻擊**：故意延遲提交結果
3. **Sybil攻擊**：創建多個偽身份
4. **共謀攻擊**：多個惡意節點協同攻擊

系統設計確保在上述攻擊下仍能維持安全性和活性。

**安全性理論分析**：

我們的系統安全性可以透過以下機率模型分析：

$$\mathbb{P}(\text{系統被攻破}) \leq \mathbb{P}(\text{樂觀期間攻擊未被偵測}) + \mathbb{P}(\text{樂觀期間攻擊有被偵測}) \times \mathbb{P}(\text{PBFT共識被攻破})$$

由於 $\mathbb{P}(\text{樂觀期間攻擊未被偵測}) + \mathbb{P}(\text{樂觀期間攻擊有被偵測}) = 1$，上式可簡化為：

$$\mathbb{P}(\text{系統被攻破}) \leq 1 - \mathbb{P}(\text{樂觀期間攻擊有被偵測}) \times (1 - \mathbb{P}(\text{PBFT共識被攻破}))$$

**實務安全性分析**：

在實務上，只要存在一個勤奮的善意驗證者持續監控鏈上數據並適時發起挑戰，系統即可獲得接近PBFT等級的安全性保證。具體而言：

1. **攻擊偵測機率**：假設至少有一個善意驗證者 $v_h$ 能夠正確偵測惡意聚合，則：
   $$\mathbb{P}(\text{樂觀期間攻擊有被偵測} | v_h \text{ 監控中}) \approx 1$$

2. **PBFT安全性**：當 $f < \frac{n}{3}$ 時，PBFT共識無法被攻破：
   $$\mathbb{P}(\text{PBFT共識被攻破} | f < \frac{n}{3}) = 0$$

因此，在理想情況下（至少一個善意驗證者積極監控且滿足PBFT條件），系統的整體安全性為：

$$\mathbb{P}(\text{系統被攻破}) \approx 0$$

這證明了我們混合Optimistic-PBFT機制的有效性：在大多數情況下以樂觀模式高效運作，在檢測到威脅時自動切換至具有完整拜占庭容錯保證的PBFT模式。

**信任模型對比**：

與其他方案相比，本研究採用雙層信任模型，結合了效率與安全性：

| 方案 | 信任假設 | 仲裁機制 | 計算環境 | 安全性 |
|------|---------|---------|---------|--------|
| 傳統 PBFT [9] | M-of-N (>2/3) | 每次都執行 PBFT | 原生環境 | 高（Byzantine 容錯） |
| opML [3] | 1-of-N | Fraud Proof | FPVM（受限） | 中（依賴誠實挑戰者） |
| zkML [1][4] | 數學級（無需信任） | 零知識證明 | 算術化（受限） | 極高（數學保證） |
| **本研究** | **1-of-N + M-of-N（雙層）** | **PBFT 共識** | **原生環境** | **高（雙層防禦）** |

這種雙層模型的優勢在於：
- **相比 opML**：有 PBFT 作為最後防線，安全性更高
- **相比 zkML**：無需複雜的證明生成，效率更高
- **相比傳統 PBFT**：正常情況下樂觀通過，效率大幅提升

## I. 計算複雜度分析

### 相對於傳統PBFT的效率提升（主要貢獻）

傳統PBFT方案（如FLCoin [9]）在每次聚合時都需要執行完整的PBFT共識協議，這導致：

**(1) 高通信開銷**
- PBFT需要 O(n²) 的通信複雜度，其中 n 為驗證者數量
- 每次聚合需要多輪消息交換：Pre-Prepare → Prepare (n 個消息) → Commit (n 個消息)
- 當驗證者數量增加時，通信成本呈平方級增長

**(2) 高延遲**
- 每次聚合都需要等待多輪通信完成（至少 2 輪）
- 需要等待 >2/3 節點響應才能達成共識
- 在網絡延遲較高或節點地理分布廣泛的場景中，延遲更加顯著

**(3) 無差異化處理**
- 無論實際威脅等級如何，每次聚合都執行相同的昂貴協議
- 在低威脅場景下（大多數情況），這種「過度保護」造成資源浪費

**本研究的混合Optimistic-PBFT機制**通過樂觀通過實現效率提升：
- **正常情況（無挑戰）**：通信開銷降至 O(1)，聚合者只需發布一次結果，無需多輪消息交換
- **異常情況（被挑戰）**：觸發 PBFT 共識，通信開銷為 O(n²)
- **平均效率**：設挑戰發生的概率為 p（通常 p << 1），平均開銷 = O(1) × (1-p) + O(n²) × p ≈ O(1)

當 p 較小時（例如 p < 0.1），平均效率提升接近 O(n²)，使得系統可以支援更多驗證者而不顯著影響效率。

### 詳細複雜度分析

假設聯邦學習需要進行 $R$ 個回合，有 $N$ 個聚合器和 $V$ 個驗證者。在拜占庭容錯的條件下，系統最多可容忍 $f = \lfloor \frac{V-1}{3} \rfloor$ 個惡意驗證者。我們分析三種不同情境下的計算複雜度：

### 1. 最樂觀情境（所有聚合器誠實）

在此情境下，系統僅使用輪替機制，每個聚合器的平均工作負載為：

$$W_{\text{最樂觀}} = \frac{R}{N}$$

系統總計算複雜度為 $O(R)$，與傳統的單聚合器系統相同，但分散在 N 個節點上。

**特性分析**：
- 線性可擴展性：增加聚合器數量直接減少單個節點負載
- 無額外驗證開銷
- 適合信任環境的高效運作

### 2. 最悲觀情境（惡意驗證者惡意挑戰）

若有惡意驗證者在每個回合都惡意發起挑戰（犧牲其質押），系統將在每回合啟動PBFT共識。此時，每個驗證者的工作負載為：

$$W_{\text{最悲觀}} = R \times V$$

系統總計算複雜度為 $O(R \times V^2)$，等同於傳統PBFT的複雜度。

**特性分析**：
- 計算負載最重的情況
- 需要所有驗證者參與每次聚合驗證
- 提供最高等級的安全保證

### 3. 實際運作情境（PBFT最大惡意節點數）

在實務中，我們假設：
- 有 $f$ 個惡意聚合器
- 善意驗證者僅對惡意聚合發起挑戰
- 每個惡意聚合器平均負責 $\frac{R}{N}$ 個回合
- 每次挑戰需要 $V$ 個驗證者參與

則每個驗證者的工作負載包含：

$$W_{\text{實際}} = \frac{R}{N} + f \times \frac{R}{N} \times V = \frac{R}{N}(1 + f \times V)$$

當 $f$ 很小時（通常 $f \ll N$），實際工作負載接近最樂觀情況。

**實際參數分析**：

考慮一個具體例子：$R=100$, $N=10$, $V=21$, $f=3$

- 最樂觀：$W = \frac{100}{10} = 10$
- 最悲觀：$W = 100 \times 21 = 2100$  
- 實際：$W = 10(1 + 3 \times 21) = 640$

實際工作負載遠低於最悲觀情況。

### 4. 計算效率比較

相較於傳統PBFT，我們的混合機制在實際運作下的效率提升為：

$$\text{效率提升比} = \frac{R \times V^2}{\frac{R}{N}(1 + f \times V)} = \frac{N \times V^2}{1 + f \times V}$$

當 $f \ll V$ 且 $N$ 較大時：

$$\text{效率提升比} \approx \frac{N \times V^2}{f \times V} = \frac{N \times V}{f}$$

這顯示效率提升與聚合器數量 $N$ 成正比，與惡意節點數 $f$ 成反比。

**漸近複雜度分析**：

- **樂觀模式**：$O(\frac{R}{N})$ per aggregator
- **PBFT模式**：$O(R \times V)$ per validator
- **混合模式**：$O(\frac{R}{N}(1 + f \times V))$ per validator

當 $N \gg 1$ 且 $f$ 為常數時，混合模式的複雜度主要由第一項決定，實現了接近樂觀模式的效率。

## J. 計算通用性對比（次要貢獻）

雖然 opML 和 zkML 等方案提供了不同的安全保證和效率權衡，但它們都面臨計算通用性限制，無法支援聯邦學習中的任意聚合操作。相較之下，本研究通過使用 PBFT 作為仲裁機制，驗證者在原生環境執行聚合，實現了對任意聚合算法和模型規模的支援。

### opML 的計算限制

opML [3] 使用 fraud proof 進行挑戰仲裁，需要通過 FPVM (Fault Proof Virtual Machine) 重新執行計算。這導致：

**(1) 記憶體限制**
- FPVM 記憶體上限為 4GB，無法載入大型模型
- 對於 7B 參數以上的大型語言模型（每個參數 4 bytes，總計 28GB+），完全無法在 FPVM 中載入
- 即使是中型模型（如 ResNet-152），載入完整模型參數也接近上限

**(2) 複雜邏輯分解困難**
- 需要將聚合邏輯分解為 VM 指令層級
- 對於帶正則化的優化問題（如 FedProx），需要分解複雜的優化步驟
- 對於需要排序/距離計算的 Byzantine-robust 算法（如 Krum、Median、Trimmed Mean），分解過程極其複雜甚至不可行
- 無法支援未來提出的新聚合算法

**(3) 無 GPU 加速**
- FPVM 必須在 CPU 上模擬執行，無法利用 GPU 加速
- 對於深度學習模型的聚合操作，CPU 執行速度比 GPU 慢數十倍甚至上百倍
- 驗證時間隨模型規模線性增長，大型模型驗證可能耗時數小時

### zkML 的計算限制

zkML [1][4] 使用零知識證明進行驗證，需要將計算「算術化」(arithmetization) 為算術電路。這導致：

**(1) 模型規模限制**
- 對 7B+ 參數模型「完全不可行」，實際可驗證上限僅約 18M 參數 [1][2]
- 這意味著 zkML 無法驗證現代大型語言模型（GPT、LLaMA、Claude 等）的聚合
- 即使是中型 Vision Transformer 模型也超出可驗證範圍

**(2) 算法限制**
- 只能驗證可高效算術化的簡單算法（如 FedAvg）
- 無法處理需要複雜邏輯的 Byzantine-robust 算法（如 Krum、Median、Trimmed Mean）
- 對於涉及條件分支、排序、比較等操作的算法，算術化開銷極高

**(3) 證明開銷**
- 證明生成「慢數個數量級」，例如 ResNet50 聚合需約 55 分鐘 [8]
- 對於更大的模型，證明時間可能達到小時級別
- 證明驗證雖然快速，但生成成本使得系統整體效率低下

### 本研究的優勢

**關鍵差異**：本研究的挑戰仲裁機制是 PBFT 共識（而非 fraud proof 或零知識證明）

**(1) 驗證者在原生環境執行**
- 不需要 FPVM，不需要算術化
- 可以直接使用 PyTorch、TensorFlow 等完整框架
- 支援所有原生運算操作（矩陣運算、梯度計算、優化步驟等）

**(2) 支援任意聚合算法**
- ✅ 基礎算法：FedAvg、FedProx、q-FedAvg
- ✅ Byzantine-robust 算法：Krum、Median、Trimmed Mean、Bulyan
- ✅ 自適應算法：FedAdam、FedYogi、FedAdagrad
- ✅ 甚至包括未來提出的新算法

**(3) 支援任意模型規模**
- ✅ 7B-175B 參數的大型語言模型
- ✅ 大型 Vision Transformer（ViT-Huge、ViT-Giant）
- ✅ 多模態模型（CLIP、Flamingo 等）
- 唯一限制是驗證者節點的硬體資源，而非協議本身

**(4) 原生框架與 GPU 加速**
- 可使用完整的 PyTorch/TensorFlow 和 GPU/TPU 環境
- 聚合速度與本地訓練相當
- 硬體加速充分利用，驗證時間大幅縮短

**(5) 高效仲裁**
- PBFT 共識（分鐘級）遠快於 zkML 的證明生成（數十分鐘到小時級）
- 即使觸發挑戰，系統仍能保持合理的響應時間
- 適合需要快速迭代的生產環境

### 方案對比總結

| 方案 | 效率（正常情況） | 計算通用性 | 信任模型 | 適用場景 |
|------|------------------|----------|--------|-----------|
| 傳統 PBFT | 低（每次 O(n²)） | 高（原生執行） | M-of-N (>2/3) | 高威脅 + 小規模驗證者 |
| opML [3] | 高（樂觀通過） | 中等（受 FPVM 限制） | 1-of-N | 中型模型 + 簡單算法 |
| zkML [1][4] | 低（證明生成慢） | 極低（18M 參數上限） | 數學級信任 | 小模型 + 簡單算法 + 極高信任要求 |
| **本研究 (Optimistic PBFT)** | **高（樂觀通過）** | **高（原生執行）** | **1-of-N + M-of-N（雙層）** | **生產環境的通用 FL 應用** |

**總結**：opML 和 zkML 的方案雖然在信任模型或透明度上有各自的優勢，但在聯邦學習場景中，它們受限於各自驗證機制的計算能力。本研究通過使用 PBFT 作為仲裁機制，在保持樂觀通過效率的同時，實現了對任意聚合操作的支援，使其適合生產環境的真實聯邦學習應用。
